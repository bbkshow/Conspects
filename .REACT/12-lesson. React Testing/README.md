#Введение в тестирование
Большое приложение это всегда высокая вероятность появления ошибок. Без тестирования приложение часто проверяют вручную, а если приложение старое и с большим функционалом то иногда оно выглядит как черный ящик. Здесь на помощь нам приходит автоматизированное тестирование функциональности приложения. Тестирование это когда мы пишем код который автоматически проверяет, не появились ли ошибки при внесении изменений в наше приложение.

В принципе программисты пишут чаще всего модульное тестирование. Модульное тестирование выполняет проверку логики приложения на уровне функции или метода; Модульное тестирование применяется ко всем видам приложений.

По подходу написания тесты делятся на два типа.

-   Code first. Вначале выполняется разработка, а затем тестирование. То есть сначала происходит написание кода, реализуется функциональность нашего приложение, а затем мы пишем тест на реализованную функциональность и тут уже или дорабатываем функциональность или переходим к следующей задаче разработки
-   Test first. Это другой подход. Еще до написания функциональности нашего приложения пишется тест, на будущую функциональность. И только после реализации тестов мы переходим к написанию функциональности нашего приложения.

Методологически тесты делят на два вида

-   TDD - разработка через тестирование (Test-Driven Development)
-   BDD - разработка через реализацию поведения (Behavior-Driven Development).
    Как в подходах TDD, так и в BDD, тесты пишутся заранее до написания фактического кода. Написание тестов в первую очередь помогает спрогнозировать ход разработки, что в конечном итоге предотвращает пропуск каких-либо моментов в функциональности работы приложения. Как видно из схемы, BDD работает поверх TDD.

#Библиотеки для тестирования
Библиотеки для тестирования — это специальные инструменты, помогающие в процессе тестирования. Конечно можно написать собственную библиотеку запуска своих тестов, но на данный сообщество уже выполнило огромный объем работы и разработало огромное количество инструментов для тестирования, поэтому проще будет использовать их.

Технологический стек для модульного тестирования:
Runner, Reporter#
Необходимы, чтобы исполнить тесты. Модульный тест это обычный JavaScript файл, но чтобы воспользоваться добавленными функциями исполнителей тестов, например запускать несколько тестов за раз, сообщать об ошибках или успешном завершении нам необходим исполнитель тестов. Мы будете использовать Jest, но есть альтернативы Mocha и Jasmine или Ava.

SPY, Mock#
При написании тестов мы избегаем их связывания с другими частями инфраструктуры нашего приложения. Таким образом другие не тестируемые функции, должны быть заменены «поддельной» функцией, которая ведет себя так, как от нее ожидают, и тут нам на помощь придут стабы (stubs) и моки (mock) Разница в терминах в том, что стаб ничего не проверяет, а лишь имитирует заданное состояние, а мок – это объект, у которого есть ожидания. Например, что тестируемая функция должна быть вызвана определенное число раз. Для тестирования stubs и mock мы используем Jest, но и есть другие библиотеки Sinon и Testdouble.

Matchers#
Библиотеки для суждений по типу - a больше b?. Уже создано множество решений, облегчающие написание утверждения для наших тестов. Jest поставляется со встроенными методами утверждения. Альтернативные популярные решения Chai и Shouldjs.

Coverage#
Покрытие тестами. Есть способы определения того, какие части нашего приложения покрыты тестами. Это показатель, который служит ориентиром при определении того, насколько хорошо протестирован наш код. Jest использует популярный инструмент под названием Istanbul.

#Jest
Jest — инструмент командной строки, построенный на основе другой популярной библиотеки тестирования Jasmine. Разработкой Jest занимается Facebook, и Jest часто используется вместе с React и вполне логично фулл-стек разработчику в стеке MERN использовать для модульного тестирования именно его.

Преимущества и особенности Jest:
Встроеная в библиотеку имитация модулей JavaScript/Node упрощает изоляцию кода при модульном тестировании
Чтобы начать работать с библиотекой нет необходимости в подготовке по сравнению с другими библиотеками выполнения тестов, например для Mocha требуется импортирование Chai, подключение Istanbul и т.д.
Изолированное (sandboxed) и параллельное выполнение тестов, что приводит к ускорению их выполнения
Обеспечивает модульность, разнообразную настройку и адаптируемость
Библиотеки для модульного тестирования используют одни и те же конструкции для определения тестов и их наборов и Jest не есть исключением в этом случае.

Конструкции:

describe - набор тестов
test (или it) - тестовый случай
beforeAll - подготовка перед тестированием
beforeEach - подготовка для каждого набора или тестового случая
afterAll - завершающие действия после тестирования
afterEach - завершающие действия для каждого набора или случая
Команда describe определяет набор тестов. Он используется в качестве контейнера для набора тестов. Команда test используется для единичного теста или по другому тестового случая. Другие конструкции, такие как beforeAll, afterAll, beforeEach и afterEach, как видим из названия выполняются перед или после набора тестов или тестового случая. При beforeEach и afterEach внутрений код этих функций выполняется многократно вместо одного раза. Тесты должны содержать как минимум по одной команде describe и test и неограниченное количество. Остальные команды не являются обязательными

Давайте создадим простой пример. Для использования Jest, в новой папку проекта необходимо выполнить команду

npm init -y
Это создаст файл package.json. После установим Jest:

npm i jest -D
Теперь необходимо открыть файл package.json и вручную изменить запись команды test на jest, как показано ниже. Мы добавили команду тестирования.

{
"name": "test-jest",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"test": "jest"
},
"keywords": [],
"author": "",
"license": "ISC",
"devDependencies": {
"jest": "^26.6.1"
}
}

#Пишем свои тесты
#Запуск теста производится теперь командой

npm run test
